#!/usr/bin/env python

#
# Ideas:
#
# - less a particular file without having to 'check it out'. co in the background
# - location/path
# - finish out the root/meta path stuff
# - doc cmdline args, do help
# 
# - filter out cvs and gits verbose outputs
#

import os, sys, re, types, commands, stat


(CMD_STATUS, CMD_CLONE, CMD_COMMIT, CMD_ADD, CMD_REMOVE, CMD_LOG, CMD_REVERT,
 CMD_UPDATE, CMD_PULL, CMD_PUSH, CMD_SYNC, CMD_PEND, CMD_URL, CMD_BACKUP,
 CMD_DIFF) = range(0, 15)

CMD_NAMES = {
    CMD_STATUS : "status",
    CMD_CLONE : "clone",
    CMD_COMMIT : "commit",
    CMD_ADD : "add",
    CMD_REMOVE : "remove",
    CMD_LOG : "log",
    CMD_REVERT : "revert",
    CMD_UPDATE : "update",
    CMD_PULL : "pull",
    CMD_PUSH : "push",
    CMD_SYNC : "sync",
    CMD_PEND : "pend",
    CMD_URL : "url",
    CMD_BACKUP : "backup",
    CMD_DIFF : "diff",
    }

# Yeah a trie would be better, but its really not required and I dont feel like
# making one, so there.
CMDS = {
    "status" : CMD_STATUS,
    "stat" : CMD_STATUS,
    "s" : CMD_STATUS,
    "clone" : CMD_CLONE,
    "co" : CMD_CLONE,
    "commit" : CMD_COMMIT,
    "com" : CMD_COMMIT,
    "ci" : CMD_COMMIT,
    "add" : CMD_ADD,
    "a" : CMD_ADD,
    "remove" : CMD_REMOVE,
    "rem" : CMD_REMOVE,
    "del" : CMD_REMOVE,
    "log" : CMD_LOG,
    "revert" : CMD_REVERT,
    "update" : CMD_UPDATE,
    "up" : CMD_UPDATE,
    "pull" : CMD_PULL,
    "push" : CMD_PUSH,
    "sync" : CMD_SYNC,
    "pending" : CMD_PEND,
    "pend" : CMD_PEND,
    "url" : CMD_URL,
    "backup" : CMD_BACKUP,
    "bkup" : CMD_BACKUP,
    "diff" : CMD_DIFF,
    }


class VC(object):
    def __init__(self, name, metadir, toponly, metacmd, cmds):
        self.name = name
        self.metadir = metadir
        self.toponly = toponly
        self.metacmd = metacmd
        self.cmds = cmds

    def testPath(self, start):
        return os.path.exists(os.path.join(start, self.metadir))

    def runCmd(self, cmd, argv, noexit=False, ignore_ret=False,
               capture_output=False):
        if isinstance(cmd, int):
            if isinstance(self.cmds[cmd], types.StringType):
                cmd = "%s %s %s" % (self.metacmd, self.cmds[cmd], " ".join(argv))
            elif isinstance(self.cmds[cmd], types.ListType):
                isfirst = True
                for subcmd in self.cmds[cmd]:
                    if isfirst:
                        isfirst = False
                        print "Running:", CMD_NAMES[subcmd]
                    else:
                        print "\nContinue: %s (Y/n) " % CMD_NAMES[subcmd], 
                        ret = sys.stdin.readline()
                        if ((not ret) or (len(ret) == 0) or (ret == "\n") or
                            ret.startswith("y") or ret.startswith("Y")):
                            pass
                        else:
                            print "Exiting early"
                            sys.exit(-1)
                    if self.runCmd(subcmd, argv, True, ignore_ret=ignore_ret,
                                   capture_output=capture_output) != 0:
                        print "Command failed, exiting early"
                return
            else:
                self.cmds[cmd](argv)
                return
        else:
            cmd = "%s %s %s" % (self.metacmd, cmd, " ".join(argv))
        if capture_output:
            ret = commands.getstatusoutput(cmd)
            if ((not noexit) or ((not ignore_ret) and (ret[0] != 0))):
                sys.exit(ret[0])
            else:
                return ret[1]
        else:
            ret = os.system(cmd)
            if ((not noexit) or ((not ignore_ret) and (ret != 0))):
                sys.exit(ret)
            else:
                return ret

    def backupFile(self, path):
        tpath = path
        index = None
        while True:
            if index is None:
                tpath = path.replace("%s", "")
            else:
                tpath = path % ("-%d" % index)
            try:
                ret = os.stat(tpath)
            except OSError, e:
                if e.errno == 2:
                    return tpath.replace("%s", "")
                else:
                    raise e
            if index is None:
                index = 0
            else:
                index = index + 1
        return path.replace("%s", "")

class SVN(VC):
    RX_URL = re.compile("://")

    def __init__(self):
        VC.__init__(self, "svn", ".svn", False, "svn",
                    ["status", "checkout", "commit", "add", "remove", "log",
                     "revert", "update", "update", "commit",
                     [CMD_STATUS, CMD_UPDATE, CMD_COMMIT], # SYNC
                     "status -u", self.cmdURL, self.cmdBackup, "diff"])
        
    def cmdURL(self, argv):
        try:
            entries = open(".svn/entries", "ro")
            for line in entries:
                if self.RX_URL.search(line):
                    print line.strip()
                    break
        except Exception, e:
            print "failed to open file:", e

    def cmdBackup(self, argv):
        ret = self.runCmd("info", [], noexit=True, capture_output=True)
        rev = None
        for line in ret.split("\n"):
            if line.startswith("Revision: "):
                words = line.split(":")
                rev = words[1].strip()
                break
        path = "backup-%s" % rev
        path = self.backupFile(path + "%s.diff")
        self.runCmd("diff > %s" % path, [], noexit=True)
        print "Backed up to:", path


class HG(VC):
    RX_TIP = re.compile("^tip[ \t]+.*")

    def __init__(self):
        VC.__init__(self, "hg", ".hg", True, "hg",
                    ["status", "clone", "commit", "add", "remove", "log",
                     "revert", "update", "pull", "push",
                     # SYNC
                     [CMD_STATUS, CMD_PULL, CMD_UPDATE, CMD_COMMIT, CMD_PUSH],
                     self.cmdPend, "paths", self.cmdBackup, "diff"])

    def cmdPend(self, argv):
        print "Remote pending changesets:"
        self.runCmd("incoming", argv, True, True)
        print "\nLocal pending changesets:"
        rev = self.runCmd("identify -n", [], noexit=True,
                          capture_output=True).strip()
        rev = int(rev.rstrip("+"))
        ret = self.runCmd("tags", [], noexit=True, capture_output=True)
        for line in ret.split("\n"):
            if self.RX_TIP.match(line):
                words = line.split(" ")
                tip = int(words[-1:][0].split(":")[0])
                break
        if tip >= rev + 1:
            self.runCmd("log -r %d:tip" % (rev + 1), argv)

    def cmdBackup(self, argv):
        ret = self.runCmd("identify -n", [], noexit=True, capture_output=True)
        path = self.backupFile("backup-r" + ret.strip().rstrip("+") + "%s.diff")
        self.runCmd("diff > %s" % path, [], noexit=True)
        print path

VCS = [
    ### hg
    HG(),
    ### git
    VC("git", ".git", True, "git",
       ["status", "clone", "commit", "add", "rm", "log", "reset --hard",
        "pull", "fetch", "push", "SYNC", "PENDING", "URL", "BACKUP", "diff"]),
    ### svn
    SVN(),
    ### cvs
    VC("cvs", "CVS", False, "cvs",
       ["status", "checkout", "commit", "add", "remove", "log", "update -C",
        "update", "update", "commit", "SYNC", "PENDING", "URL", "BACKUP",
        "diff"]),
    ]


def detectVC():
    start = os.getcwd()
    for vc in VCS:
        if vc.toponly:
            if recurseDetectVC(start, vc):
                return vc
        elif vc.testPath(start):
            return vc

def recurseDetectVC(start, vc):
    path = start.split(os.sep)
    for idx in range(0, len(path)):
        if vc.testPath(os.sep.join(path[:-idx])):
            return True

vc = detectVC()
if not vc:
    print "Unable to detect version control system"
    sys.exit(1)

if len(sys.argv) > 1:
    cmd = sys.argv[1]
else:
    cmd = "status"

try:
    cmd = CMDS[cmd]
except:
    pass
vc.runCmd(cmd, sys.argv[2:])
