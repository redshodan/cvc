#!/usr/bin/env python

#
# Ideas:
#
# - less a particular file without having to 'check it out'. co in the background
# - location/path
# - finish out the root/meta path stuff
# - doc cmdline args, do help
# 
# - filter out cvs and gits verbose outputs
#

import os, sys, re, types, commands, stat


(CMD_STATUS, CMD_CLONE, CMD_COMMIT, CMD_ADD, CMD_REMOVE, CMD_LOG, CMD_REVERT,
 CMD_UPDATE, CMD_PULL, CMD_PUSH, CMD_SYNC, CMD_PEND, CMD_URL, CMD_BACKUP,
 CMD_DIFF, CMD_TOP) = range(0, 16)

CMD_NAMES = {
    CMD_STATUS : "status",
    CMD_CLONE : "clone",
    CMD_COMMIT : "commit",
    CMD_ADD : "add",
    CMD_REMOVE : "remove",
    CMD_LOG : "log",
    CMD_REVERT : "revert",
    CMD_UPDATE : "update",
    CMD_PULL : "pull",
    CMD_PUSH : "push",
    CMD_SYNC : "sync",
    CMD_PEND : "pend",
    CMD_URL : "url",
    CMD_BACKUP : "backup",
    CMD_DIFF : "diff",
    CMD_TOP : "top",
    }

# Yeah a trie would be better, but its really not required and I dont feel like
# making one, so there.
CMDS = {
    "status" : CMD_STATUS,
    "stat" : CMD_STATUS,
    "s" : CMD_STATUS,
    "clone" : CMD_CLONE,
    "co" : CMD_CLONE,
    "commit" : CMD_COMMIT,
    "com" : CMD_COMMIT,
    "ci" : CMD_COMMIT,
    "add" : CMD_ADD,
    "a" : CMD_ADD,
    "remove" : CMD_REMOVE,
    "rem" : CMD_REMOVE,
    "del" : CMD_REMOVE,
    "log" : CMD_LOG,
    "revert" : CMD_REVERT,
    "update" : CMD_UPDATE,
    "up" : CMD_UPDATE,
    "pull" : CMD_PULL,
    "push" : CMD_PUSH,
    "sync" : CMD_SYNC,
    "pending" : CMD_PEND,
    "pend" : CMD_PEND,
    "url" : CMD_URL,
    "loc" : CMD_URL,
    "backup" : CMD_BACKUP,
    "bkup" : CMD_BACKUP,
    "diff" : CMD_DIFF,
    "top" : CMD_TOP,
    }


class VC(object):
    VCS = []

    def __init__(self, name, metadir, metacmd, cmds):
        self.name = name
        self.metadir = metadir
        self.metacmd = metacmd
        self.cmds = cmds
        self.topdir = None

    @staticmethod
    def detectVC(cmd):
        if cmd == CMD_CLONE:
            return VC.detectVCByUrl(cmd)
        else:
            return VC.detectVCByPath()

    @staticmethod
    def detectVCByUrl(cmd):
        return

    @staticmethod
    def detectVCByPath():
        def recurseDetectVC(start, vc):
            last = None
            path = start.split(os.sep)
            for idx in range(0, len(path)):
                if idx == 0:
                    cur = os.sep.join(path)
                else:
                    cur = os.sep.join(path[:-idx])
                if vc.testPath(cur):
                    last = cur
                elif last:
                    return last
            return None
        start = os.getcwd()
        for vc in VC.VCS:
            top = None
            last = None
            path = start.split(os.sep)
            for idx in range(0, len(path)):
                if idx == 0:
                    cur = os.sep.join(path)
                else:
                    cur = os.sep.join(path[:-idx])
                if vc.testPath(cur):
                    last = cur
                elif last:
                    top = last
                    break
            if top:
                vc.topdir = top
                return vc

    def matchURL(self, url):
        pass
    
    def extractURL(self, url):
        pass
    
    def testPath(self, start):
        return os.path.exists(os.path.join(start, self.metadir))

    def runCmd(self, cmd, argv, noexit=False, ignore_ret=False,
               capture_output=False):
        orgcmd = cmd
        if isinstance(cmd, int):
            if isinstance(self.cmds[cmd], types.StringType):
                cmd = "%s %s %s" % (self.metacmd, self.cmds[cmd], " ".join(argv))
            elif isinstance(self.cmds[cmd], types.TupleType):
                cmd = "%s %s" % (" ".join(self.cmds[cmd]), " ". join(argv))
            elif isinstance(self.cmds[cmd], types.ListType):
                isfirst = True
                for subcmd in self.cmds[cmd]:
                    if isfirst:
                        isfirst = False
                        print "Running:", CMD_NAMES[subcmd]
                    else:
                        print "\nContinue: %s (Y/n) " % CMD_NAMES[subcmd], 
                        ret = sys.stdin.readline()
                        if ((not ret) or (len(ret) == 0) or (ret == "\n") or
                            ret.startswith("y") or ret.startswith("Y")):
                            pass
                        else:
                            print "Exiting early"
                            sys.exit(-1)
                    if self.runCmd(subcmd, argv, True, ignore_ret=ignore_ret,
                                   capture_output=capture_output) != 0:
                        print "Command failed, exiting early"
                return
            else:
                self.cmds[cmd](argv)
                return
        else:
            cmd = "%s %s %s" % (self.metacmd, cmd, " ".join(argv))
        cmd = self.filterCmd(cmd, orgcmd)
        if capture_output:
            ret = commands.getstatusoutput(cmd)
            if ((not noexit) or ((not ignore_ret) and (ret[0] != 0))):
                sys.exit(ret[0])
            else:
                return ret[1]
        else:
            ret = os.system(cmd)
            if ((not noexit) or ((not ignore_ret) and (ret != 0))):
                sys.exit(ret)
            else:
                return ret

    def filterCmd(self, cmd, orgcmd):
        return cmd
        
    def backupFile(self, path):
        tpath = path
        index = None
        while True:
            if index is None:
                tpath = path.replace("%s", "")
            else:
                tpath = path % ("-%d" % index)
            try:
                ret = os.stat(tpath)
            except OSError, e:
                if e.errno == 2:
                    return tpath.replace("%s", "")
                else:
                    raise e
            if index is None:
                index = 0
            else:
                index = index + 1
        return path.replace("%s", "")

    def cmdTop(self, argv):
        print self.topdir


class SVN(VC):
    RX_URL = re.compile("://")

    def __init__(self):
        VC.__init__(self, "svn", ".svn", "svn",
                    ["status", "checkout", "commit", "add", "remove", "log",
                     "revert", "update", "update", "commit",
                     [CMD_STATUS, CMD_UPDATE, CMD_COMMIT], # SYNC
                     "status -u", ("svnpath",), self.cmdBackup, "diff",
                     self.cmdTop])

    def cmdBackup(self, argv):
        ret = self.runCmd("info", [], noexit=True, capture_output=True)
        rev = None
        for line in ret.split("\n"):
            if line.startswith("Revision: "):
                words = line.split(":")
                rev = words[1].strip()
                break
        path = "backup-r%s" % rev
        path = self.backupFile(path + "%s.diff")
        self.runCmd("diff > %s" % path, [], noexit=True)
        print "Backed up to:", path


class HG(VC):
    RX_TIP = re.compile("^tip[ \t]+.*")
    URL_PREFIX = "hg://"

    def __init__(self):
        VC.__init__(self, "hg", ".hg", "hg",
                    ["status", "clone", "commit", "add", "remove", "log",
                     "revert", "update", "pull", "push",
                     # SYNC
                     [CMD_STATUS, CMD_PULL, CMD_UPDATE, CMD_COMMIT, CMD_PUSH],
                     self.cmdPend, "paths", self.cmdBackup, "diff", self.cmdTop])

    def matchURL(self, url):
        if url.startswith(self.URL_PREFIX):
            return True
        return False
    
    def extractURL(self, url):
        return url.lstrip(self.URL_PREFIX)

    def cmdPend(self, argv):
        print "Remote pending changesets:"
        self.runCmd("incoming", argv, True, True)
        print "\nLocal pending changesets:"
        rev = self.runCmd("identify -n", [], noexit=True,
                          capture_output=True).strip()
        rev = int(rev.rstrip("+"))
        ret = self.runCmd("tags", [], noexit=True, capture_output=True)
        for line in ret.split("\n"):
            if self.RX_TIP.match(line):
                words = line.split(" ")
                tip = int(words[-1:][0].split(":")[0])
                break
        if tip >= rev + 1:
            self.runCmd("log -r %d:tip" % (rev + 1), argv)

    def cmdBackup(self, argv):
        ret = self.runCmd("identify -n", [], noexit=True, capture_output=True)
        path = self.backupFile("backup-r" + ret.strip().rstrip("+") + "%s.diff")
        self.runCmd("diff > %s" % path, [], noexit=True)
        print path


class GIT(VC):
    def __init__(self):
        VC.__init__(self, "git", ".git", "git",
                    ["status", "clone", "commit", "add", "rm", "log",
                     "reset --hard", "pull", "fetch", "push", "SYNC", "PENDING",
                     "URL", "BACKUP", "diff", self.cmdTop])


class CVS(VC):
    def __init__(self):
        VC.__init__(self, "cvs", "CVS", "cvs",
                    ["status", "checkout", "commit", "add", "remove", "log",
                     "update -C", "update", "update", "commit", "SYNC",
                     "PENDING", "URL", "BACKUP", "diff", self.cmdTop])


VC.VCS.extend([SVN(), HG(), GIT(), CVS()])


if __name__ == '__main__':
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
    else:
        cmd = "status"

    try:
        cmd = CMDS[cmd]
        vc = VC.detectVC(cmd)
        os.chdir(vc.topdir)
        if not vc:
            print "Unable to detect version control system"
            sys.exit(1)
    except IndexError:
        pass
    vc.runCmd(cmd, sys.argv[2:])
